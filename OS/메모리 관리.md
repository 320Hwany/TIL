## 가상 메모리

운영체제가 하는 일 중 대표적인 것 중 하나가 메모리 관리이다. 한정된 메모리를 효율적으로 사용해야 한다.  
가상 메모리는 메모리 관리 기법 중 하나로 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 사용자에게  
매우 큰 메모리로 보이게 만드는 것이다.  

물리 메모리 + SWAP 공간(디스크 공간) -> 가상 메모리(가짜 메모리) 
이러한 방식으로 사용할 수 있다.    

## 페이징 

메모리에 프로세스를 올리는데 프로세스마다 메모리에서 차지하는 공간이 다르다. 따라서 빈공간이 생겨 이러한 공간을 활용하지 못하는 문제가 있다.  
이러한 문제를 해결하기위해 현대 운영체제는 불연속 할당인 페이징 기법을 사용한다.   

프레임은 실제 메모리를 사용하는 최소 크기 단위를 말한다. 프로그램을 프레임과 동일한 크기로 자르고 이렇게 잘린 것 하나하나를 페이지라고 한다.   
따라서 프레임은 실제 메모리, 페이지는 가상 메모리를 사용한다.  

## 스와핑, 페이지 폴트

프로세스의 주소 공간에는 존재하지만 메모리(RAM)에 없다면 하드 디스크에서 가져와야 한다.   
이렇게 메모리에 없는 데이터에 접근하는 경우를 페이지 폴트라고 한다.  
또한 사용하지 않으면 하드 디스크로 내리고 필요할 때 메모리로 가져오면서 관리하는 것을 스와핑이라고 한다.  

## 스레싱(thrashing)

페이지 폴트율이 높으면 스와핑이 많이 일어나면서 CPU의 활동 시간이 적어진다.   
그러면 운영체제는 CPU가 일을 하고 있지 않다고 판단해 더 많은 프로세스를 메모리에 올린다.  
이러한 악순환이 반복되며 스레싱이 발생한다.  

이러한 스레싱 문제를 해결하기 위한 방법으로는 2가지가 있다.

1. 작업 세트(working set) 

프로세스의 작업 단위를 묶는 것이다. 메모리에 올리거나 하드디스크로 내리는 것을 페이지 하나하나가 아니라 작업 단위로 하는 것이다.  

2. PFF(page fault frequency)

페이지 폴트 빈도를 조절하는 방식으로 상한선과 하한선을 두고 상한선에 도달하면 페이지를 늘리고 하한선에 도달하면 페이지를 줄인다.

## 페이지 테이블, TLB

페이지 테이블은 Page, Frame, Valid, Auth, Reference, Dirty 프로세스와 관련된 정보를 저장하고 이는 메모리에 저장되어 있다.  
이러한 정보를 보고 메모리의 어디에 위치한 지를 찾아 전달한다. 하지만 문제점은 페이지 테이블도 메모리에 있기 때문에 CPU와 메모리 사이를  
2번 왔다 갔다 해야한다. 이를 해결하기 위한 방법으로 TLB가 있다.    

TLB는 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시이다. 페이지 테이블에 있는 정보를 CPU가 테이블까지 가지 않도록 하여  
속도를 향상 시킬 수 있는 캐시 계층이다.

## 페이지 교체 알고리즘

스와핑할 때 어떤 페이지를 고를 지 역시 운영체제가 결정한다. 페이지 교체 알고리즘으로는 LRU로 참조가 가장 오래된 페이지를 바꾸는 경우가 있다.  
또한 clock 알고리즘이라고도 불리는 NUR은 메모리에 올라와 있는 모든 페이지가 각각 한 개의 reference bit(페이지 테이블에 있다)을 갖게 하고  
초기에는 모두 0이고 참조 되었으면 1이다. 시계 방향으로 돌면서 0을 찾고 0을 찾은 순간 해당 프로세스를 교체하며 1로 바꾸는 알고리즘이다.  

출처 : 우테코 10분 테코톡 (리눅스 메모리 관리)
