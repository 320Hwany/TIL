## 프록시 

엔티티를 조회할 때 연관된 엔티티들이 항상 사용되는 것은 아니다. Member와 Team 엔티티가 있을 때 필요한 정보는 Member인데  
Member를 조회할 때 Team까지 데이터베이스에서 함께 조회하는 것은 효율적이지 않다.   
따라서 Team 엔티티 값을 실제 사용하는 시점에 데이터베이스에서 조회하는 방법이 필요하다. 그 방법이 지연로딩이다.   
이러한 지연 로딩 기능을 사용하려면 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요하고 이것을 프록시 객체라고 한다.  

```
Member member = em.find(Member.class, "member");
```
위와 같이 엔티티를 직접 조회하면 조회한 엔티티를 실제 사용하든 사용하지 않든 데이터베이스를 조회하게 된다.  

```
Member member = em.getReference(Member.class, "member");
```
위와 같이 호출하면 JPA는 데이터베이스를 조회하지 않고 실제 엔티티 객체도 생성하지 않는다.  
대신에 데이터베이스 접근을 위임한 프록시 객체를 반환한다.   

프록시 클래스는 실제 클래스를 상속 받아서 만들어지므로 실제 클래스와 겉모양이 같다.   
또한 프록시 객체는 실제 객체에 대한 참조를 보관한다. 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다.  

### 프록시 초기화 과정

프록시 객체가 메소드를 호출해서 실제 데이터를 조회하려고 할 때 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에  
실제 엔티티 생성을 요청하는데 이것을 초기화라고 한다.   

사용자가 실제 객체를 사용하려고 함 -> 프록시 객체는 영속성 컨텍스트에 초기화 요청 -> DB 조회   
-> 실제 엔티티 생성 -> 프록시 객체가 가지고 있는 참조 값으로 실제 객체에 접근

### 프록시의 특징  

1. 프록시 객체는 처음 사용할 때 한번만 초기화 된다. 
2. 프록시 객체를 초기화한다고 해서 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. (프록시 객체를 통해서 실제 엔티티에 접근)  
3. 영속성 컨텍스트에 찾는 엔티티가 이미 있다면 em.getReference()를 호출해도 프록시가 아닌 실제 엔티티를 반환한다. 
4. 초기화는 영속성 컨텍스트의 도움을 받아야 가능하다. 준영속 상태의 프록시를 초기화하면 문제가 발생한다.  

## 즉시 로딩과 지연 로딩

즉시 로딩 : 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다. 하이버네이트는 가능하면 SQL 조인을 사용해서 한 번에 조회한다.
```
@ManyToOne(fetch = FetchType.EAGER)
```
지연 로딩 : 연관된 엔티티를 프록시로 조회한다. 프록시를 실제 사용할 때 초기화하면서 데이터베이스를 조회한다.
```
@ManyToOne(fetch = FetchType.LAZY)
```
하지만 서로 같이 조회하는 경우가 많더라도 즉시 로딩은 사용하지 말자.  
문제는 JPQL을 사용할 때이다. JPQL을 사용하여 먼저 member만 select 하면 즉시 로딩으로 설정되어 있으면  
각 member와 연관된 team이 각각의 쿼리로 나가 N+1 문제를 발생시킨다. 

@ManyToOne, @OneToOne은 기본이 즉시 로딩이고 @OneToMany, @ManyToMany는 기본이 지연 로딩이다.  
따라서 @ManyToOne, @OneToOne을 사용할 경우 모두 지연 로딩으로 바꿔서 모든 연관관계에서 지연 로딩을 사용하자.  

## 영속성 전이 : CASCADE

영속성 전이를 사용하면 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장할 수 있다.  
```
@OneToMany(mappedBy = "parent", cascade = CascadeType.PERSIST)
```
CASCADE의 종류에는 ALL(모두 적용), PERSIST(영속), MERGE(병합), REMOVE(삭제), REFRESH, DETACH가 있다.  
보통 ALL, PERSIST, REMOVE를 사용한다.  

## 고아 객체 

JPA는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데 이것을 고아 객체 제거라고 한다.  
부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제된다.  
```
orphanRemoval = true
```
이 기능은 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능이다.  
따라서 특정 엔티티가 개인 소유하는 엔티티에만 이 기능을 적용해야 한다.   
이러한 이유로 orphanRemoval은 @OneToOne, @OneToMany에만 사용할 수 있다.  
또한 참조를 제거하는 경우 말고도 부모 객체를 제거하면 자식도 같이 제거된다. (CascadeType.REMOVE를 설정한 것과 같다)  

### 영속성 전이 + 고아 객체, 생명주기

두 가지 기능을 동시에 사용하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있다.  
1. 자식을 저장하려면 부모에 등록만 하면된다. (CASCADE)
자식을 persist로 영속성 컨텍스트에 저장할 필요없이 부모에 등록만 하면 영속 상태가 된다.  
2. 자식을 제거하려면 부모에서 제거하면 된다. (orphanRemoval)
자식을 제거하려면 부모에서 자식의 연관관계만 없애면 된다.   

이러한 방식으로 자식의 생명주기를 따로 고려할 필요없이 부모에서 등록, 제거를 할 수 있다.

출처 : 자바 ORM 표준 JPA 프로그래밍 (김영한)



