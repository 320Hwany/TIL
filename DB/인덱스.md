## 인덱스란?

인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치이다. 예를들어 책의 목차를 예시로 들 수 있다.  
특정 페이지를 처음부터 차례대로 찾는다면 오래걸리지만 목차를 보면 훨씬 더 빠르게 찾을 수 있다.  
인덱스는 항상 최신 정렬 상태를 유지해야 한다. 인덱스도 데이터베이스 크기의 약 10%를 차지하는 하나의 객체이다.  

데이터 베이스에서는 인덱스를 활용하여 검색 성능을 향상 시키고 이는 WHERE 절을 통해 활용된다.   
```
SELECT * FROM student WHERE age > 20;  
```

## B- 트리 (Balanced tree)

인덱스는 보통 B-트리라는 자료 구조로 이루어져 있다. 이는 루트 노드, 브랜치 노드, 리프 노드로 나눌 수 있다.   
루트 노드, 브랜치 노드는 자식 페이지 정보를 가지고 있고 리프 노드는 실제 데이터 페이지를 가지거나 (클러스터링 인덱스)  
실제 데이터의 주소 페이지를 가지고 있다. (논-클러스터링 인덱스)   
또한 B-트리는 트리 높이가 같고 자식 노드를 2개 이상 가질 수 있다. (이진 탐색 트리의 단점 극복)  

## 인덱스의 장점과 단점

인덱스를 활용하면 SELECT의 성능을 향상 시킬 수 있다. 그렇다면 INSERT, DELETE, UPDATE의 경우에는 어떨까?   

만약 노드의 페이지가 비어있다면 큰 비용을 들이지 않고 INSERT 할 수 있다. 하지만 페이지가 가득찬 상태라면 새로운 데이터를  
추가할 여유 공간이 없어 페이지 변화가 발생한다. 즉 페이지 분할이 발생한다. 이러한 경우에는 INSERT를 할 때 오히려 성능이 나빠진다.  
DELETE의 경우에도 먼저 조회를 할 때는 빠르게 찾을 수 있다. 하지만 데이터 베이스에서 삭제하지 않고 사용안함 표시로 페이지가 낭비된다.  
UPDATE도 마찬가지로 조회를 할 때는 성능이 좋지만 UPDATE 과정이 DELETE 후 INSERT를 하는 것이므로 페이지가 낭비된다.  

이렇게 SELECT의 경우에는 성능이 향상되었지만 INSERT, DELETE, UPDATE를 할 때는 저하될 수 있다.  

## 인덱스 종류

MySQL의 경우 클러스터형 인덱스, 논-클러스터형 인덱스(세컨더리 인덱스)가 있다.   

1. 클러스터형 인덱스

primary key, unique not null 옵션을 붙이면 클러스터형 인덱스로 만들 수 있다.  
실제 데이터 자체가 정렬되어 있고 테이블당 1개만 존재 가능하고 리프 페이지가 데이터 페이지와 같다.  
따라서 클러스터형 인덱스는 사전과 비슷하다고 할 수 있다.   

2. 논-클러스터형 인덱스   

unique 옵션을 붙이거나 create index 명령어를 기반으로 논-클러스터형 인덱스로 만들 수 있다.   
실제 데이터 페이지는 그대로이고 별도의 인덱스 페이지를 생성하기 때문에 추가 공간이 필요하다.  
테이블당 여러 개 존재한다. 리프 페이지에 실제 데이터 페이지 주소를 담고있다.   
따라서 논-클러스터형 인덱스는 목차와 비슷하다고 할 수 있다.  

## 인덱스 적용 기준

1. 카디널리티가 높은 (중복도가 낮은) 컬럼을 선택  
2. 조건절이 없다면 인덱스가 사용되지 않는다. 따라서 WHERE, JOIN, ORDER BY 절에 자주 사용되는 컬럼을 선택
3. INSERT, UPDATE, DELETE를 사용하면 성능이 저하될 수 있으므로 자주 사용하지 않는 컬럼을 선택  
4. 규모가 작지 않은 테이블에서 사용

출처 : 데이터베이스 인덱스 (우테코 10분 테코톡)

